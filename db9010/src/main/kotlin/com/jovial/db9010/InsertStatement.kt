package com.jovial.db9010

import java.sql.PreparedStatement
import java.sql.ResultSet
import java.sql.Statement


/**
 * An SQL insert statement.  See [Database.insertInto].
 *
 * Note that this statement type doesn't have a `getReusable()` method, like
 * [SelectQuery.Builder.getReusable].  That's because, for an insert statment, the
 * lambda that identifies the columns also sets their values.  The overhead
 * of establishing a mapping if those functions were to be separated exceeds the
 * slight overhead of looking up the statement in the cache.
 */
class InsertStatement private constructor(
    table: Table
) : ColumnSetter(table) {

    /**
     * Key used for caching insert statements by [Database].
     */
    data class Key(private val table: Table, private val columns : List<Column<*>>)

    /**
     * A builder for an insert statement where the client code is not interested in the
     * [ResultSet] generated by the [PreparedStatement].  See [Database.insertInto].
     */
    class BuilderNoResults(private val db: Database, private val table: Table) {

        /**
         * Execute [setBody] to set any needed [Parameter] values, then execute the insert statment.
         * Returns the value returned by [setBody].
         */
        infix fun <T> run (setBody: (InsertStatement) -> T) : T {
            val b = Builder(db, table) { _ -> }
            val result = setBody(b.setter)
            // A little dodge to remember what the setBody gives us (even though it's
            // probably Unit):  We give the Builder a stub set body, and we call the real
            // setBody ourselves.  Then, since the client isn't asking for results, we call the
            // builder with a stub resultBody, and return whatever the setBody gave us.
            b run { _ -> }
            return result
        }
    }

    /**
     * A builder for an insert statement where the client code is interested in the
     * [ResultSet] generated by the [PreparedStatement].  See [Database.insertInto].
     */
    class Builder(private val db: Database, private val table: Table,
                  private val setBody: (InsertStatement) -> Unit)
        : StatementBuilder<Key>() {

        internal val setter = InsertStatement(table)

        /**
         * Execute the underlying [PreparedStatement], then call [resultBody] with
         * a [Result] object containing the [ResultSet] generated by
         * [PreparedStatement.getGeneratedKeys]
         */
        infix fun <T> run(resultBody: (Result) -> T) : T {
            setBody(setter)
            return db.insertStatements.withStatement(this) { stmt ->
                for (i in setter.columns.indices) {
                    setter.setters[i](i+1, stmt)
                }
                val rows = stmt.executeUpdate()
                assert(rows == 1)
                val resultSet = stmt.getGeneratedKeys()
                val ok = resultSet.next()
                assert(ok)
                val indexMap : Map<Column<*>, Int> =
                    table.primaryKeys.indices.associateBy({ i -> table.primaryKeys[i] }, { i -> i + 1 })
                val r = Result(resultSet, table.primaryKeys, indexMap)
                try {
                    resultBody(r)
                } finally {
                    r.close()
                }
            }
        }

        override val statementKey: Key get() = Key(table, setter.columns)

        override fun prepareStatement(): PreparedStatement {
            val sql = StringBuilder()
            sql.append("INSERT INTO ${table.tableName} (")
            appendCommaList(sql, setter.columns, { col -> col.sqlName })
            sql.append(") VALUES (")
            appendCommaList(sql, setter.columns, { _ -> "?" })
            sql.append(")")
            val s = sql.toString()
            dbLogger.fine(s)
            return db.connection.prepareStatement(s, Statement.RETURN_GENERATED_KEYS)
        }
    }

    /**
     * A holder for the [ResultSet] created by [PreparedStatement.getGeneratedKeys] after an
     * insert statement is run.
     */
    class Result (
        private val resultField: ResultSet,
        columns: List<Column<*>>,
        resultIndex: Map<Column<*>, Int>
    ) : ResultsHolder(columns, resultIndex) {

        override val result get() = resultField
    }
}

